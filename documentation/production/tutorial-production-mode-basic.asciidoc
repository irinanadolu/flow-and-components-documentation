---
title: Preparing your application for Production
order: 1
layout: page
---

ifdef::env-github[:outfilesuffix: .asciidoc]

= Preparing your application for Production

== Simple steps for production mode build

By default (such as when downloading a project from vaadin.com/start), Vaadin applications are set up to run in the development mode. 
This requires a bit more memory and CPU power, but enables easier debugging. 
When deploying your app to your users, you will want to switch to the production mode instead.

The main difference between the development and production modes is that in the development mode Vaadin uses Webpack to serve JavaScript files to the browser, instead of the Java server the app is running on. 
This is so that if you change a JS or CSS file, your changes are picked up and served automatically. 
When in production mode, you do not want this extra overhead since the files will not change; it is more efficient to prepare JavaScript and CSS files once, during build, and let one server (the Java Server) serve all requests. 
At the same time, the client resources can be optimized and minified to reduce the load on the network and browser even further.

All Vaadin POM files downloaded from vaadin.com have the following built-in Maven configuration for creating a production mode build:

.pom.xml
[source, xml]
----
<profiles>
    <profile>
        <id>production</id>
        <properties>
            <vaadin.productionMode>true</vaadin.productionMode>
        </properties>
		
        <!-- 
		.. configuration depending on environment ..
		 -->
         <executions>
             <execution>
                 <goals>
                     <goal>build-frontend</goal>
                 </goals>
                 <phase>compile</phase>
             </execution>
         </executions>
		 <!--
		 .. more configuration ..
		 -->
    </profile>
</profiles>
----

The actual content of the profile will depend on what environment your app is running in, but all of the variations do two things:

. Setting the property `vaadin.productionMode` to `true`
. Calling the Maven goal `vaadin:build-frontend`

To create a production build, you can call `mvn clean package -Pproduction`. 
This will build a JAR or WAR file with all the dependencies and transpiled front end resources, ready to be deployed. 
The file can be found in the `target` folder after the build completes.

If you do not have the the production Maven profile in your POM file, the easiest way to get it is to get a project base from https://vaadin.com/start matching your environment (Spring boot, Jakarta EE, or plain Java), and copy the production profile from the downloaded POM file.

Having production mode be a separate Maven profile is recommended so that you do not get any unexpected problems due to
production settings when running in the development mode. 

[NOTE]
If your OS is 64-bit, please make sure to use a 64-bit JDK installation as well. There are known issues when running the build on 32-bit JDKs in 64-bit environments.

[NOTE]
For an older project running in the compatibility mode (bower mode), please see the V10 documentation about the production mode build.

== What Is Transpilation and Bundling

Transpilation in Vaadin means converting all ES6 JavaScript to ES5 JavaScript format for older browsers (IE11 and Safari 9). 
All Vaadin components are written using ES6, and consist of several JavaScript and CSS files. 
Transpilation makes sure this newer JavaScript code also works in older browsers, such as IE11.

[NOTE]
IOS 10 has a known issue with https://caniuse.com/#search=let[`let bindings in for loops are incorrectly treated as function-scoped instead of block scoped`], in this case, all browsers running on it need the transpilation, too.

During the build, minimization is done to make the files smaller. 
When minifying code, it is often obscured, which makes it harder to read, hence this is not done in the development mode.

Bundling is an optimization where we merge multiple files to a single collection so that the browser doesn't need to
request so many files from the server. 
This makes the application load faster.

== Checklist for the production mode app artifact

Vaadin Servlet configures itself from the `flow-build-info.json` file, which is located in the `META-INF/VAADIN/config/` resource package.
The location of resources differs for different artifact types, for example:

* Spring Boot jar file places resources into the `BOOT-INF/classes/` folder in the jar file;
* WAR archive places resources into the `WEB-INF/classes/` folder.

If the production mode has been activated properly, the contents of the `flow-build-info.json` should be as follows:

.flow-build-info.json
[source, json]
----
{
  "compatibilityMode": false,
  "productionMode": true,      <1>
  "enableDevServer": false,
  "chunks": {
    "fallback": {
      "jsModules": [
        "@vaadin/vaadin-icons/vaadin-icons.js",
        "@vaadin/vaadin-grid/src/vaadin-grid-tree-toggle.js",
// etc etc
        "frontend://ironListConnector.js"
      ],
      "cssImports": [
      ]
    }
  }
}
----

<1> Note that the `productionMode` property is set to `true`

It's very important to have this file on classpath in production mode exactly once:

* If the file is missing, Vaadin Servlet will throw an exception at runtime.
  The project `flow-build-info.json` file is generated by Vaadin plugin, in the `prepare-frontend` Maven goal,
  then modified in `build-frontend` task to enable production mode.

* If the file is present multiple times on the classpath,
  then Vaadin tries to choose which one is the right one which should be coming
  from the main project. Sometimes it's not possible to do so, and then Vaadin
  prints a warning message and chooses the first `flow-build-info.json` file,
  which depends on the classpath ordering which in turn may depend on the ordering
  of files on the file system or in the WAR/JAR archive.
+
This usually happens when a Vaadin addon
incorrectly includes the `flow-build-info.json` file in the jar file.
That's a bug in the addon packaging which need to be fixed and the
`flow-build-info.json` file removed from addon's jar file.

For the reasons stated above, keep in mind to have the `flow-build-info.json` file on the classpath exactly once,
and always coming from your main project.

A file named `META-INF/VAADIN/config/stats.json` is generated by Maven Plugin as
well - it's important to check for the presence of this file in the resources folder.

When packaging for production a `webpack` executable
is run; this happens in the `build-frontend` Maven goal.
Webpack is then responsible for packaging everything from `frontend/` and `node_modules` into
the precompiled JavaScript files bundle.
The bundle is located in the `META-INF/VAADIN/build/` resource folder.
The folder contents should look like this (the hash is going to differ on every build):

----
├── vaadin-2-18d67c4ccff7e93b081a.cache.js
├── vaadin-2-18d67c4ccff7e93b081a.cache.js.gz
├── vaadin-3-b0147df339bf18eb7618.cache.js
├── vaadin-3-b0147df339bf18eb7618.cache.js.gz
├── vaadin-4-ee1d2e45569f7eca4292.cache.js
├── vaadin-4-ee1d2e45569f7eca4292.cache.js.gz
├── vaadin-5-5e9292474e82143d0a27.cache.js
├── vaadin-5-5e9292474e82143d0a27.cache.js.gz
├── vaadin-bundle-19a00eae62ad7cddd291.cache.js
├── vaadin-bundle-19a00eae62ad7cddd291.cache.js.gz
├── vaadin-bundle.es5-b1c1a3cc054c62ad7949.cache.js
├── vaadin-bundle.es5-b1c1a3cc054c62ad7949.cache.js.gz
└── webcomponentsjs
    ├── bundles
    │   ├── webcomponents-ce.js
    │   ├── webcomponents-ce.js.map
    │   ├── webcomponents-sd-ce.js
    │   ├── webcomponents-sd-ce.js.map
    │   ├── webcomponents-sd-ce-pf.js
    │   ├── webcomponents-sd-ce-pf.js.map
    │   ├── webcomponents-sd.js
    │   └── webcomponents-sd.js.map
    ├── custom-elements-es5-adapter.js
    ├── LICENSE.md
    ├── package.json
    ├── README.md
    ├── src
    │   └── entrypoints
    │       ├── custom-elements-es5-adapter-index.js
    │       ├── webcomponents-bundle-index.js
    │       ├── webcomponents-ce-index.js
    │       ├── webcomponents-sd-ce-index.js
    │       ├── webcomponents-sd-ce-pf-index.js
    │       └── webcomponents-sd-index.js
    ├── webcomponents-bundle.js
    ├── webcomponents-bundle.js.map
    └── webcomponents-loader.js
----

